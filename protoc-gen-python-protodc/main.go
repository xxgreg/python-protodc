package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

func debug(args ...any) {
	_, _ = fmt.Fprintln(os.Stderr, args...)
}

func main() {
	protogen.Options{}.Run(
		func(plugin *protogen.Plugin) error {
			plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
			for _, file := range plugin.Files {
				if file.Generate {
					filePath := strings.Replace(file.Proto.GetName(), ".", "_", -1) + "dc.py"
					debug("protoc-gen-python-protodc", filePath)
					out := plugin.NewGeneratedFile(filePath, "")
					err := generate(out, file)
					if err != nil {
						return err
					}
				}
			}
			return nil
		},
	)
}

type Output struct {
	Buf    bytes.Buffer
	Indent int
}

func (o *Output) Write(s string) {
	o.Buf.WriteString(strings.Repeat("    ", o.Indent))
	o.Buf.WriteString(s)
	o.Buf.WriteString("\n")
}

func (o *Output) RenderOne(line string, replaces ...string) {
	o.Render([]string{line}, replaces...)
}

func (o *Output) Render(lines []string, replaces ...string) {
	r := strings.NewReplacer(replaces...)
	for line := range lines {
		o.Write(r.Replace(lines[line]))
	}
}

func generate(w io.Writer, f *protogen.File) error {
	out := &Output{}

	// split out imports into function
	out.Write(`
# autogenerated by protoc-gen-python-protodc

from dataclasses import dataclass, field
from datetime import datetime
import enum
from typing import Any, Union, Optional

import google.protobuf.message
import google.protobuf.json_format

import protodc

`)

	// import the pb2 types for the current package.
	pkg := protopkg(f.Proto.GetName()) + "_pb2"
	out.Write("import " + pkg)

	// import example.other.v1.other_proto
	for _, dep := range f.Proto.Dependency {
		if strings.HasPrefix(dep, "google/protobuf/") {
			continue
		}
		out.Write("import " + protopkg(dep) + "_protodc")
	}

	out.Write("")
	out.Write("")

	for _, e := range f.Enums {
		enum := newEnum(e)
		generateEnumClass(out, enum)
	}

	for _, m := range f.Messages {
		msg := newMessage(m)
		generateMsg(out, msg)
	}

	_, err := w.Write(out.Buf.Bytes())
	if err != nil {
		return err
	}
	return nil
}

func generateMsg(out *Output, msg Message) {

	for _, o := range msg.Oneofs {
		if o == nil {
			continue
		}
		oneofClass(out, msg, *o)
	}

	out.Write("")
	out.Write("@dataclass")
	out.Write("class " + msg.PyName + ":")
	out.Indent += 1

	for _, f := range msg.Fields {
		if f.Oneof != nil {
			oneofFields(out, msg, f)
			continue
		}
		t, ok := getTemplate(f.RepeatKind, f.ValueType.Kind)
		if !ok {
			debug("no template", f.FullName)
			continue
		}
		t.WriteField(out, newReplaceOpts(f))
	}
	out.Write("")

	if len(msg.Oneofs) > 0 {
		oneofPostInit(out, msg)
	}

	out.Render([]string{
		"def to_protojson(self):",
		"    return google.protobuf.json_format.MessageToJson(self.to_protobuf())",
		"",
		"@staticmethod",
		"def from_protojson(json_str):",
		"    pb = ~py_msg_pb_type~()",
		"    google.protobuf.json_format.Parse(json_str, pb)",
		"    return ~py_msg_type~.from_protobuf(pb)",
		"",
	},
		"~py_msg_type~", msg.PyName,
		"~py_msg_pb_type~", msg.PyPbPkgName,
	)

	out.Render([]string{
		"def to_protobuf(self, target_pb: google.protobuf.message.Message = None, depth: int = 0) -> '~py_pb_pkg_name~':",
		"    if depth > 100:",
		"        raise Exception('to_protobuf(): too much nesting in ~full_name~: often caused by a circular reference.')",
		"",
		"    if target_pb is not None:",
		"        pb = target_pb",
		"    else:",
		"        pb = ~py_pb_pkg_name~()",
		"",
	},
		"~py_pb_pkg_name~", msg.PyPbPkgName,
		"~full_name~", msg.Fullname,
		"~py_type~", msg.PyName,
	)

	out.Indent += 1
	for _, f := range msg.Fields {
		if f.Oneof != nil {
			oneofToPB(out, msg, f)
			continue
		}
		t, ok := getTemplate(f.RepeatKind, f.ValueType.Kind)
		if !ok {
			debug("no template", f.FullName)
			continue
		}
		t.WriteToPB(out, newReplaceOpts(f))
	}
	out.Write("")
	out.Write("return pb")
	out.Indent -= 1

	out.Render([]string{
		"",
		"@staticmethod",
		"def from_protobuf(pb: '~py_pb_pkg_name~', depth: int = 0) -> '~py_name~':",
		"    if depth > 100:",
		"        raise Exception('from_protobuf(): too much nesting in ~full_name~: often caused by a circular reference.')",
		"",
		"    dc = ~py_name~()",
		"",
	},
		"~py_pb_pkg_name~", msg.PyPbPkgName,
		"~py_name~", msg.PyName,
		"~full_name~", msg.Fullname,
	)

	out.Indent += 1
	for _, f := range msg.Fields {
		if f.Oneof != nil {
			oneofFromPB(out, msg, f)
			continue
		}
		t, ok := getTemplate(f.RepeatKind, f.ValueType.Kind)
		if !ok {
			debug("no template", f.FullName)
			continue
		}
		t.WriteFromPB(out, newReplaceOpts(f), f.ValueType.HasPresence)
	}
	out.Write("")
	out.Write("return dc")
	out.Indent -= 1
	out.Write("")

	// Oneof Getters and Setters
	for _, o := range msg.Oneofs {
		for _, f := range o.Oneof.Fields {
			oneofGettersAndSetters(out, msg, o.Oneof, f)
		}
	}

	// end class
	out.Indent -= 1
}
